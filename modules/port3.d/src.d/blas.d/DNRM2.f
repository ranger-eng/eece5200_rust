      DOUBLE PRECISION FUNCTION DNRM2(N, X, INCX)
      INTEGER N, INCX
      DOUBLE PRECISION X(INCX, 1)
      INTEGER I1MACH, NMAX, BETA, IEXP, J, EMIN
      INTEGER EMAX, T, MAX0, IOUT
      REAL FLOAT
      DOUBLE PRECISION D1MACH, S3MACH, B1, B2, S1, S2
      DOUBLE PRECISION EPS, RELERR, OVERFL, DSML, DMED, DBIG
      DOUBLE PRECISION DX, DSQRT
      DATA B1/0.0D0/
      DATA B2/0.0D0/
      DATA S1/0.0D0/
      DATA S2/0.0D0/
      DATA RELERR/0.0D0/
      DATA OVERFL/0.0D0/
      DATA NMAX/0/
C CALCULATE 2-NORM OF ROW 1 OF X ARRAY.
C AVOID ALL OVERFLOWS AND UNDERFLOWS
C I1MACH( 9) = N, THE LARGEST INTEGER
C I1MACH(10) = BETA, THE BASE FOR FLOATING-POINT NUMBERS
C I1MACH(14) = T, THE NUMBER OF BASE-BETA DIGITS IN THE MANTISSA
C I1MACH(15) = EMIN, THE MINIMUM EXPONENT
C I1MACH(16) = EMAX, THE MAXIMUM EXPONENT
C D1MACH( 2) = R, THE LARGEST FLOATING-POINT NUMBER
C EXTERNAL FUNCTIONS
C EXTERNAL FUNCTIONS
      IF (N .NE. 0) GOTO 1
         DNRM2 = 0.D0
         RETURN
C/6S
   1  IF (N .LT. 0) CALL SETERR(17H DNRM2 - N .LT. 0, 17, 1, 2)
      IF (INCX .LE. 0) CALL SETERR(20H DNRM2 - INCX .LE. 0, 20, 2, 2)
C/7S
C  1  IF (N .LT. 0) CALL SETERR(' DNRM2 - N .LT. 0', 17, 1, 2)
C     IF (INCX .LE. 0) CALL SETERR(' DNRM2 - INCX .LE. 0', 20, 2, 2)
C/
      IF (NMAX .GT. 0) GOTO 4
         NMAX = I1MACH(9)
C FIRST-TIME SWITCH
         BETA = I1MACH(10)
         T = I1MACH(14)
         EMIN = I1MACH(15)
         EMAX = I1MACH(16)
         IEXP = -((1-EMIN)/2)
C LOWER BOUNDARY OF MIDRANGE
         B1 = S3MACH(1.0D0, BETA, IEXP)
         IEXP = (EMAX+1-T)/2
C UPPER BOUNDARY OF MIDRANGE
         B2 = S3MACH(1.0D0, BETA, IEXP)
         IEXP = -((2-EMIN)/2)
C SCALING FACTOR FOR LOWER RANGE
         S1 = S3MACH(1.0D0, BETA, IEXP)
         IEXP = (EMAX+T)/2
C SCALING FACTOR FOR UPPER RANGE
         S2 = S3MACH(1.0D0, BETA, IEXP)
         OVERFL = D1MACH(2)/S2
         EPS = S3MACH(1.0D0, BETA, 1-T)
         RELERR = DSQRT(EPS)
         DBIG = 1.0D0/EPS-1.0D0
         IF (DBLE(FLOAT(NMAX)) .GT. DBIG) NMAX = DBIG
         IF (EMIN .LE. 1-2*T .AND. T+1 .LE. EMAX .AND. T .GE. MAX0(2, 6-
     1      BETA)) GOTO 3
            IOUT = I1MACH(2)
            WRITE (IOUT,  2)
   2        FORMAT (43H DNRM2 - THE ALGORITHM CANNOT BE GUARANTEED,
     1         17H ON THIS COMPUTER)
   3     CONTINUE
C/6S
   4  IF (N .GT. NMAX) CALL SETERR(20H DNRM2 - N TOO LARGE, 20, 3, 2)
C/7S
C  4  IF (N .GT. NMAX) CALL SETERR(' DNRM2 - N TOO LARGE', 20, 3, 2)
C/
      DSML = 0.0D0
      DMED = 0.0D0
      DBIG = 0.0D0
      DO  9 J = 1, N
         DX = DABS(X(1, J))
         IF (DX .LE. B2) GOTO 5
            DBIG = DBIG+(DX/S2)**2
            GOTO  8
   5        IF (DX .LE. B1) GOTO 6
               DMED = DMED+DX**2
               GOTO  7
   6           DSML = DSML+(DX/S1)**2
   7     CONTINUE
   8     CONTINUE
   9     CONTINUE
      IF (DBIG .LE. 0.0D0) GOTO 11
         DBIG = DSQRT(DBIG)
         IF (DBIG .LE. OVERFL) GOTO 10
            DNRM2 = D1MACH(2)
C/6S
            CALL SETERR(17H DNRM2 - OVERFLOW, 17, 4, 1)
C/7S
C           CALL SETERR(' DNRM2 - OVERFLOW', 17, 4, 1)
C/
            RETURN
  10     DBIG = DBIG*S2
         DMED = DSQRT(DMED)
         GOTO  16
  11     IF (DSML .LE. 0.0D0) GOTO 14
            IF (DMED .LE. 0.0D0) GOTO 12
               DBIG = DSQRT(DMED)
               DMED = DSQRT(DSML)*S1
               GOTO  13
  12           DNRM2 = DSQRT(DSML)*S1
               RETURN
  13        CONTINUE
            GOTO  15
  14        DNRM2 = DSQRT(DMED)
            RETURN
  15  CONTINUE
  16  DSML = DMIN1(DBIG, DMED)
      DBIG = DMAX1(DBIG, DMED)
      IF (DSML .GT. DBIG*RELERR) GOTO 17
         DNRM2 = DBIG
         GOTO  18
  17     DNRM2 = DBIG*DSQRT((DSML/DBIG)**2+1.0D0)
  18  RETURN
      END
